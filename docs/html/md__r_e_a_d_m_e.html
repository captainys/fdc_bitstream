<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fdc_bitstream: C++ FDC library to manipulate 2D/MFM bitstream image data</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fdc_bitstream
   </div>
   <div id="projectbrief">FDC library for MFM floppy bit stream data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">C++ FDC library to manipulate 2D/MFM bitstream image data </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md17"></a>
Description:</h1>
<p >This is a C++ library to provide FDC functions. Read and write functions mimic the actual operation of the Western Digital FD179x or Fujitsu MB8876 FDCs. The FDC library is designed to be integrated with the old PC emulator programs. <br  />
</p>
<p >This FDC library can handle raw FDD output read data before the C/D separation is applied. <br  />
 The FDC library includes a data separator and simple VFO emulation features thus, the FDC can reproduce some copy protection data, which requires precise sub-bitrate data pulse timing. <br  />
</p>
<p ><b>This library directly reads and writes the bit stream data, so the track bit stream data even after applying some write operations, is still compliant with actual floppy bit stream data.</b> <br  />
</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Supported functions:</h2>
<ul>
<li>Track read</li>
<li>Track write</li>
<li>ID read</li>
<li>Sector read</li>
<li>Sector write</li>
</ul>
<h2><a class="anchor" id="autotoc_md19"></a>
Supported floppy disk image formats:</h2>
<p >You can use <code>*.HFE</code> (for HxC floppy emulator), <code>*.MFM</code> (my original disk format), <code>*.RAW</code> (which can be generated by <a href="https://github.com/yas-sim/floppy_disk_shield_2d">floppy_disk_shield_2d</a>), and <code>*.D77</code> (or D88. Originally, developed for a PC-8801 emulator). The specification of the <code>MFM</code> and <code>RAW</code> formats was defined by myself. These format can preserve precise sub-bitrate pulse data. By default, these file formats will capture the FDD RD data at the sampling rate of 4MHz. <br  />
</p>
<h1><a class="anchor" id="autotoc_md20"></a>
API Document</h1>
<p >The API document generated by Doxygen can be found at <code>./docs/html</code> directory. Please open <a href="./docs/html/index.html"><code>./docs/html/index.html</code></a> with a browser. <br  />
 <em>Note:</em> You can't open the HTML document from GitHub. Please clone the project and open the document locally. <br  />
</p>
<h1><a class="anchor" id="autotoc_md21"></a>
How to integrate the fdc_bitstream library with your program</h1>
<ol type="1">
<li>Required files <br  />
<ul>
<li>Source codes: All C++ source codes are stored in the <code>./fdc_bitstream</code>.</li>
<li>Header files: All C++ header files are stored in the <code>./includes</code> directory. <b>Note:</b> The source codes of C++ classes for disk image handling/manipulation are in the <code>./disk_image</code> directory, but those codes are not mandatory to run <code><a class="el" href="classfdc__bitstream.html">fdc_bitstream</a></code>. <br  />
</li>
</ul>
</li>
<li>Classes</li>
</ol>
<ul>
<li>Use the <code><a class="el" href="classfdc__bitstream.html">fdc_bitstream</a></code> object to access the track data. <br  />
<ul>
<li><code><a class="el" href="classfdc__bitstream.html">fdc_bitstream</a></code> takes track data in a <code><a class="el" href="classbit__array.html">bit_array</a></code> object and performs read and write operations. <br  />
 -<code><a class="el" href="classfdc__bitstream.html">fdc_bitstream</a></code> doesn't provide <em>seek</em> and <em>restore</em> functions. It simply provides read and write functions for the track data provided. The user program must handle <em>seek</em> and <em>restore</em> equivalent operations. <br  />
</li>
</ul>
</li>
<li>Track data is held in the <code><a class="el" href="classbit__array.html">bit_array</a></code> object. <br  />
<ul>
<li>You can access the data with <em>bit address</em> with <code><a class="el" href="classbit__array.html">bit_array</a></code> object. <br  />
</li>
<li><code><a class="el" href="classbit__array.html">bit_array</a></code> object has an internal access pointer and provides streaming access. You can read and write bit data sequentially with the streaming functions. <br  />
</li>
<li>You can choose two modes when you access by the streaming functions. One is ring-buffer mode, and the other one is elastic buffer mode. <br  />
</li>
<li>In ring-buffer mode, you can access the bit data with the auto-increment pointer, and the pointer will go back to the top when it reaches the end of the buffer. <br  />
</li>
<li>In elastic buffer mode, the buffer will automatically extend as you write over the end of the buffer. <br  />
</li>
</ul>
</li>
</ul>
<p >Use one of the <code>disk_image_???</code> class to read the disk image file. Supported formats are <code>HFE</code>, <code>MFM</code>, <code>RAW</code>, and <code>D77</code> (<code>MFM</code> and <code>RAW</code> are my original format. It is not compatible any other existing disk formats which shares the same file extension). <br  />
</p><ol type="1">
<li>Software VFO <br  />
</li>
</ol>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Variable-frequency_oscillator">VFO</a> is an oscillator that can change its oscillation frequency and is used in the floppy disk drives to follow the bit rate variation of the recorded data on the floppy disks. <br  />
</li>
<li>It is one of the key component for accurate and reliable data reading. <br  />
</li>
<li>This FDC library has software VFO to read the bit stream data. The SW-VFO is still the key component for reliable data reading. <br  />
</li>
<li>You can modify or create your own VFO algorithm for better reading quality by implementing a new VFO class based on the <code><a class="el" href="classvfo__base.html" title="VFO for data separator in mfm_codec.">vfo_base</a></code> class. <br  />
</li>
</ul>
<p ><img src="./resources/class-diagram.png" alt="" class="inline"/></p>
<hr  />
<h1><a class="anchor" id="autotoc_md23"></a>
Multi format converter</h1>
<p >This project also includes a <em>simple</em> disk image converter that takes one of <code>*.HFE</code>, <code>*.RAW</code>, <code>*.MFM</code>, or <code>*.D77</code> disk image data and convert it into either one of <code>*.MFM</code> or <code>*.D77</code> disk image data. <br  />
 The image converter can accept <b>multiple image files</b> as input. The converter will inspect all tracks in the images, select the best tracks among the images, and generates a merged image (a chimera image).| |<code>-o</code>|<code>out_file</code>|Specify output file. MFM and D77 are supported.</p><ul>
<li>How to run: <div class="fragment"><div class="line">image_converter -i input_file.[hfe|raw|mfm|d77] -o output_file.[mfm|d77] [-n] [-vfo vfo_type] [-gain low high] [-v]</div>
</div><!-- fragment --> <em>Options:</em> <br  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone" colspan="2">Option   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-i</code>   </td><td class="markdownTableBodyNone"><code>filename</code>   </td><td class="markdownTableBodyNone">Input file name. The converter can accept multiple input files.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-o</code>   </td><td class="markdownTableBodyNone"><code>filename</code>   </td><td class="markdownTableBodyNone">Output file name    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" colspan="2"><code>-n</code>   </td><td class="markdownTableBodyNone">Pulse pitch normalization.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-vfo</code>   </td><td class="markdownTableBodyNone"><code>vfo_type</code>   </td><td class="markdownTableBodyNone">Specify the type of VFO to be used to decode MFM bit stream for D77 output.<br  />
0:<a class="el" href="classvfo__simple.html" title="VFO class using simple proportional error correction (P)">vfo_simple</a>, 1:<a class="el" href="classvfo__fixed.html" title="Fixed VFO class (no VFO)">vfo_fixed</a>, 2:<a class="el" href="classvfo__pid.html" title="VFO class using PID control.">vfo_pid</a>, 3:<a class="el" href="classvfo__pid2.html" title="VFO class using PID control (2)">vfo_pid2</a>, 4:<a class="el" href="classvfo__simple2.html" title="VFO class using PID control (2)">vfo_simple2</a>, 5:<a class="el" href="classvfo__pid3.html" title="VFO class using PID control.">vfo_pid3</a> 9:<a class="el" href="classvfo__experimental.html" title="VFO class using PID control.">vfo_experimental</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-gain</code>   </td><td class="markdownTableBodyNone"><code>low</code> <code>high</code>   </td><td class="markdownTableBodyNone">Set VFO gain (D77 only). e.g. <code>-gain 1.0 2.0</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" colspan="2"><code>-v</code>   </td><td class="markdownTableBodyNone">Verbose mode   </td></tr>
</table>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md24"></a>
Kryoflux RAW to MFM format converter</h1>
<p ><code><a class="el" href="kfx2mfm_8py.html">kfx2mfm.py</a></code> is a Python script to convert the disk images captured by <a href="https://kryoflux.com/">Kryoflux device</a>. <br  />
 Kryoflux can capture the disk image at a sampling rate of 24MHz, so it can preserve the disk pulse information precisely at a high resolution. <br  />
</p><ul>
<li>How to run: <div class="fragment"><div class="line">python kfx2mfm.py -i &lt;kfx raw image directory&gt;</div>
</div><!-- fragment --> <img src="https://kryoflux.com/images/kf_board_250.jpg" alt="Kryoflux" class="inline"/></li>
</ul>
<h1><a class="anchor" id="autotoc_md25"></a>
Disk image analyzer</h1>
<p >The <code>analyzer</code> is a powerful tool to inspect, validate and manipulate the disk image data. <br  />
 The analyzer has lot of feature to inspect and analyze the quality of the captured image data. <br  />
 Please refer to the <a class="el" href="md_disk_analyzer__r_e_a_d_m_e.html">README.md</a> for details. <br  />
 <img src="./resources/track_dump.png" alt="analyzer" class="inline"/></p>
<hr  />
<h1><a class="anchor" id="autotoc_md27"></a>
Directory structure - Libraries</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Directory   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="./fdc_bitstream/"><code>fdc_bitstream</code></a>   </td><td class="markdownTableBodyNone">C++ FDC library source code    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="./disk_image/"><code>disk_image</code></a>   </td><td class="markdownTableBodyNone">C++ soure files to read/write/manipulate disk image files (MFM/D77/RAW/HFE).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>include</code>   </td><td class="markdownTableBodyNone">C++ header files for the FDC library   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md28"></a>
Directory structure - Sample/Test/Tool programs, etc</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Directory   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>docs/html</code>   </td><td class="markdownTableBodyNone">FDC library API document (<code>index.html</code>)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="./disk_analyzer/"><code>disk_analyzer</code></a>   </td><td class="markdownTableBodyNone">Disk image analyze tool. You can try VFO gain and fluctuator setting. This tool can visualize how VFO behaves (VFO visualizer) and check the pulse timing distribution of the disk image (histogram).<br  />
Also, the analyzer has track data trimming feature so that you can cut out the desired portion from the track. The trimming function can be used to remove unnecessary (or excessive) track data overlapping.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="./image_converter/"><code>image_converter</code></a>   </td><td class="markdownTableBodyNone">(MFM/D77/RAW/HFE) to (MFM/D77) disk image converter. The converter will take one of mfm/raw/hfe/d77 image file, translate it into a MFM data internally, and then output the data as either one of mfm/d77.<br  />
The image converter can accept <b>multiple image files</b> as input. The converter will inspect all tracks in the images, select the best tracks among the images, and generates a merged image (a chimera image).   </td></tr>
</table>
<p>|<code>-o</code>|<code>out_file</code>|Specify output file. MFM and D77 are supported.| |<a href="./kfx2mfm/"><code>kfx2mfm</code></a>|Kryoflux <code>RAW</code> files to <code>MFM</code> disk image file converter. Kryoflux <code>RAW</code> image consists of multiple <code>RAW</code> files. Each file contains bitstream data of a track captured at the clock rate of 24MHz.| <br  />
 |<a href="./create_mfm_image/"><code>create_mfm_image</code></a>|Creates an 2D/MFM disk image with regular format (ECMA/ISO).The program will create <code>new_image.mfm</code>.| <br  />
 |<a href="./fdc_test/"><code>fdc_test</code></a>|FDC lib test program source code. You can learn how to use <code>bit_stream</code> and <code>image_???</code> classes.| <br  />
</p>
<h1><a class="anchor" id="autotoc_md29"></a>
How to build the test program and tools</h1>
<p >Build tested on Windows 11 (MSVC), and Linux (Ubuntu20, gcc). <br  />
 </p><div class="fragment"><div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">cmake ..</div>
<div class="line">cmake --build .</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md31"></a>
&lt;em&gt;Intentional&lt;/em&gt; fluctuation mechanism - for timing sensitive copy-protection data reproduction</h1>
<p >The actual floppy drive has a lot of elements that may introduce read data instability, such as spindle motor speed fluctuation, and bit pulse discontinuity by writing new data. Some copy-protect techniques intentionally cause those unstable read data at the desired point, and check whether the floppy disk is a genuine one or not by reading the unstable points several times. Most floppy image format preserves decoded MFM data, and it is impossible to reproduce this kind of copy-protect data because the data in the image is deterministic, and no timing variation happens. To reproduce such timing-dependent copy-protection data, the MFM and RAW disk image format capture the floppy drive read data at the x8 sampling rate (4MHz) of the 2D/MFM FDC bit rate (500KHz). The MFM and RAW format can preserve even irregular pulses, and therefore it can reproduce timing-sensitive copy-protection data. <br  />
</p>
<p ><b>To reproduce this kind of non-deterministic result, the FDC, <code><a class="el" href="classfdc__bitstream.html">fdc_bitstream</a></code> should have some uncertainty in its operation.</b> <br  />
 If <code><a class="el" href="classfdc__bitstream.html">fdc_bitstream</a></code> operates exactly the same everytime, the read result will be deterministic even if the floppy image contains some irregular pulses. <code><a class="el" href="classfdc__bitstream.html">fdc_bitstream</a></code> has a <code>fluctuator</code> in the VFO in the data-separator. <br  />
 In the actual floppy drive, the VFO will automatically adjust the read timing to read the data accurately. Thanks to the VFO, the floppy drives can read the data accurately even if the bit pulse speed fluctuates. However, the tracking speed of the VFO is limited. It may get unsynchronized when the bit stream has timing discontinuity, or there are irregular pulses. Once the VFO gets unsynchronized, it requires a certain time to get synchronized again, and the read data will be indeterministic during this period. <br  />
</p>
<p >You can set the VFO fluctuation rate by using <code><a class="el" href="classfdc__bitstream.html#ab37c5cb738437d0a0fad5feeaf49ae90" title="Enable FDC read operation fluctuatior. If you set the fluctuator with enable_fluctuator(1,...">fdc_bitstream::enable_fluctuator()</a></code> function. If you set <code>enable_fluctuator(1,4)</code>, the VFO operates at 3/4 and stops operation at the rate of 1/4. The operation is determined by a random generator, so the operation of the VFO will be stochastic, and the read data might be indeterministic if there are some irregular bits exiting in the bit stream. Even if you apply the fluctuator, the read data will be deterministic unless there are irregular pulses. <br  />
 The <code><a class="el" href="fdc__test_8cpp.html#a8cd5114dae85c02da78296daa44d39e2">test4()</a></code> in the <code>fdc_test</code> generates random irregular pulses at a specific region in the track data and reads the sector data multiple times with the fluctuator enabled to check whether the stochastic fluctuator works as intended. <br  />
</p>
<p ><img src="resources/corocoro.png" alt="" class="inline"/></p>
<hr  />
<h1><a class="anchor" id="autotoc_md33"></a>
Command line examples for sample programs and tools.</h1>
<div class="fragment"><div class="line">CMD&gt; create_mfm_image</div>
<div class="line"># &#39;new_image.mfm&#39; will be created.</div>
<div class="line">=== 0</div>
<div class="line">=== 1</div>
<div class="line">=== 2</div>
<div class="line"> :  :</div>
<div class="line">=== 83</div>
<div class="line"> </div>
<div class="line">CMD&gt; image_converter -i new_image.mfm -o new_image.d77</div>
<div class="line"># new_image.d77 will be created from new_image.mfm</div>
<div class="line"> </div>
<div class="line">new_image.mfm -&gt; new_image.d77</div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="autotoc_md35"></a>
MFM image data format:</h1>
<p >The default sampling rate for the MFM format is 4MHz. The data rate of the 2D/MFM format disk is 500KHz. This means, one bit cell will be recorded with eight bits of data in the MFM format. <br  />
</p>
<p ><code>|00001000|00000000|00100000|00010000|00000000| =&gt; 0x08,0x00,0x20,0x10,0x00 in MFM format</code></p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">// Header (ofst(byte) = 0)</div>
<div class="line">typedef struct mfm_header_ {</div>
<div class="line">    uint8_t     id_str[8];                  //  &quot;MFM_IMG &quot;</div>
<div class="line">    uint64_t    track_table_offset;         // </div>
<div class="line">    uint64_t    number_of_tracks;           //</div>
<div class="line">    uint64_t    spindle_time_ns;            //  Time for 1 rotation (ns unit) </div>
<div class="line">    uint64_t    data_bit_rate;              //  Data bit rate (bit/sec)    MFM=500Kbit/sec = 500,000</div>
<div class="line">    uint64_t    sampling_rate;              //  Sampling rate of the bit stream data     4MHz = 4,000,000</div>
<div class="line">} mfm_header;</div>
<div class="line"> </div>
<div class="line">// Track offset table (ofst(byte) = header.track_table_offset)</div>
<div class="line">typedef struct track_table_ {</div>
<div class="line">    uint64_t    offset;                     // Offset to the track data (unit=byte, from the top of the file == absolute offset)</div>
<div class="line">    uint64_t    length_bit;                 // Track data length (uint=bits, not bytes)</div>
<div class="line">} mfm_track_table[number_of_tracks];</div>
<div class="line"> </div>
<div class="line">// Track data * 84</div>
<div class="line">//   ofst(byte) = track_table[track#].offset</div>
<div class="line">//   size(byte) = track_table[track#].length_bit/8 + (track_table[track#].length%8)?1:0)</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
