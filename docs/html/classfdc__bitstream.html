<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fdc_bitstream: fdc_bitstream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fdc_bitstream
   </div>
   <div id="projectbrief">FDC library for MFM floppy bit stream data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classfdc__bitstream.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classfdc__bitstream-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">fdc_bitstream Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fdc__bitstream_8h_source.html">fdc_bitstream.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfdc__bitstream_1_1id__field.html">id_field</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfdc__bitstream_1_1sector__data.html">sector_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afbc1c3cb3ab7c90b3cdedaf255a0640e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#afbc1c3cb3ab7c90b3cdedaf255a0640e">fdc_bitstream</a> ()</td></tr>
<tr class="memdesc:afbc1c3cb3ab7c90b3cdedaf255a0640e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new fdc bitstream::fdc bitstream object.  <a href="classfdc__bitstream.html#afbc1c3cb3ab7c90b3cdedaf255a0640e">More...</a><br /></td></tr>
<tr class="separator:afbc1c3cb3ab7c90b3cdedaf255a0640e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e607ac3f28e6e9b15a60c69f4b11376"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#a5e607ac3f28e6e9b15a60c69f4b11376">set_fdc_params</a> (size_t sampling_rate, size_t data_bit_rate, double bit_window_ratio=0.75f)</td></tr>
<tr class="memdesc:a5e607ac3f28e6e9b15a60c69f4b11376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set FDC parameters.  <a href="classfdc__bitstream.html#a5e607ac3f28e6e9b15a60c69f4b11376">More...</a><br /></td></tr>
<tr class="separator:a5e607ac3f28e6e9b15a60c69f4b11376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948703f45052ce4a5a1f73f4c126df43"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#a948703f45052ce4a5a1f73f4c126df43">get_track_length</a> (void)</td></tr>
<tr class="separator:a948703f45052ce4a5a1f73f4c126df43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdff4c84a7787e014101f0f7c1d0283"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#a9cdff4c84a7787e014101f0f7c1d0283">set_track_data</a> (<a class="el" href="classbit__array.html">bit_array</a> track_data)</td></tr>
<tr class="memdesc:a9cdff4c84a7787e014101f0f7c1d0283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new track data. Set a new track data in new a <a class="el" href="classbit__array.html">bit_array</a>.  <a href="classfdc__bitstream.html#a9cdff4c84a7787e014101f0f7c1d0283">More...</a><br /></td></tr>
<tr class="separator:a9cdff4c84a7787e014101f0f7c1d0283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9ccb2de40c6ae4c94bb963b4817515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbit__array.html">bit_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#a9a9ccb2de40c6ae4c94bb963b4817515">get_track_data</a> (void)</td></tr>
<tr class="memdesc:a9a9ccb2de40c6ae4c94bb963b4817515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the track data in <a class="el" href="classbit__array.html">bit_array</a>.  <a href="classfdc__bitstream.html#a9a9ccb2de40c6ae4c94bb963b4817515">More...</a><br /></td></tr>
<tr class="separator:a9a9ccb2de40c6ae4c94bb963b4817515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028dd1120ce703253589a87186ec5ec3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#a028dd1120ce703253589a87186ec5ec3">set_pos</a> (size_t bit_pos)</td></tr>
<tr class="memdesc:a028dd1120ce703253589a87186ec5ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current bit position in the track buffer. The position is the bit position in the track buffer. When the sampling rate of the track buffer is 4MHz, one bit means 250ns (1/4MHz). When you set the position to 10 and the sampling rate is 4MHz, the new position will be 2.5us from the top of the track buffer. (1/4MHz * 10 = 2.5us)  <a href="classfdc__bitstream.html#a028dd1120ce703253589a87186ec5ec3">More...</a><br /></td></tr>
<tr class="separator:a028dd1120ce703253589a87186ec5ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc397441b7777ca7271458d736199e09"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#afc397441b7777ca7271458d736199e09">get_pos</a> (void)</td></tr>
<tr class="memdesc:afc397441b7777ca7271458d736199e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current position in the track buffer.  <a href="classfdc__bitstream.html#afc397441b7777ca7271458d736199e09">More...</a><br /></td></tr>
<tr class="separator:afc397441b7777ca7271458d736199e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d0a24862c9cdf24aa1664b48f2f917"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#a91d0a24862c9cdf24aa1664b48f2f917">is_wraparound</a> (void)</td></tr>
<tr class="separator:a91d0a24862c9cdf24aa1664b48f2f917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5b4821c9b9cac9d7ee88e77fb5d098"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#a5d5b4821c9b9cac9d7ee88e77fb5d098">clear_wraparound</a> (void)</td></tr>
<tr class="separator:a5d5b4821c9b9cac9d7ee88e77fb5d098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37c5cb738437d0a0fad5feeaf49ae90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#ab37c5cb738437d0a0fad5feeaf49ae90">enable_fluctuator</a> (size_t numerator, size_t denominator)</td></tr>
<tr class="separator:ab37c5cb738437d0a0fad5feeaf49ae90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b39dd619d4fdc04b89392a1a87c7589"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#a0b39dd619d4fdc04b89392a1a87c7589">disable_fluctuator</a> (void)</td></tr>
<tr class="separator:a0b39dd619d4fdc04b89392a1a87c7589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a75a1f7be3131cf88ba60d3fe49cd71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#a8a75a1f7be3131cf88ba60d3fe49cd71">set_vfo_gain</a> (double low, double high)</td></tr>
<tr class="separator:a8a75a1f7be3131cf88ba60d3fe49cd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56d06aee0676001c3b245c144f12a6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#aa56d06aee0676001c3b245c144f12a6b">write_data</a> (uint8_t data, bool mode=false, bool write_gate=true)</td></tr>
<tr class="memdesc:aa56d06aee0676001c3b245c144f12a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a byte data to the track buffer at the current position and advance the position for one byte. This function writes a byte data to the track buffer. The data wil be written at the current position, and the pointer will advance for one byte. This function also supports FD179x/MB8877 special codes. When the 'mode' is set to 'true', the special codes are recognized and handled respectively. When the 'write_gate' is set to 'false', this function will not perform actual data writing but advance the pointer. You can use this feature for dummy data writing (or just skip certain bytes).  <a href="classfdc__bitstream.html#aa56d06aee0676001c3b245c144f12a6b">More...</a><br /></td></tr>
<tr class="separator:aa56d06aee0676001c3b245c144f12a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19159752b4c24f253f7f44709e1bfd61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#a19159752b4c24f253f7f44709e1bfd61">read_data</a> (uint8_t &amp;data, bool &amp;missing_clock, bool ignore_missing_clock=true, bool ignore_sync_field=true)</td></tr>
<tr class="memdesc:a19159752b4c24f253f7f44709e1bfd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a byte from the current position in the track buffer and advance the position for one byte. When reading an ID field and a block of sector data body, ignore_missing_clock and ignore_sync_field must be set to 'true'. Otherwise, unexpected patten match to the missing-clock-pattern or sync-field-pattern may happen. If this situation occurs, the data separator will perform forcible phase correction and this causes read data error. Adversely, you must set ignore_missing_clock and ignore_sync_field to 'false' when you are searching for address markers (such as IDAM, A1* A1* A1* FE).  <a href="classfdc__bitstream.html#a19159752b4c24f253f7f44709e1bfd61">More...</a><br /></td></tr>
<tr class="separator:a19159752b4c24f253f7f44709e1bfd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea60a7ed3b79255840fac28a5a20c02"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#abea60a7ed3b79255840fac28a5a20c02">read_track</a> (void)</td></tr>
<tr class="memdesc:abea60a7ed3b79255840fac28a5a20c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read track. Reads track data from the current position until the pointer reaches to the end of the track (no wrap around).  <a href="classfdc__bitstream.html#abea60a7ed3b79255840fac28a5a20c02">More...</a><br /></td></tr>
<tr class="separator:abea60a7ed3b79255840fac28a5a20c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcc3997b1a78dfe74a32dd0c5ae6bf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#aebcc3997b1a78dfe74a32dd0c5ae6bf8">write_track</a> (const std::vector&lt; uint8_t &gt; &amp;track_buf)</td></tr>
<tr class="memdesc:aebcc3997b1a78dfe74a32dd0c5ae6bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write track. Start writing from the current position until all data is written. The track buffer is treated as a ring buffer, so the pointer will wrap around if the write data goes over the buffer's end. Write track recognizes MB8876/FDC179x compatible special codes such as $f5, $f6, $f7, $fb, $fe, and so on.  <a href="classfdc__bitstream.html#aebcc3997b1a78dfe74a32dd0c5ae6bf8">More...</a><br /></td></tr>
<tr class="separator:aebcc3997b1a78dfe74a32dd0c5ae6bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285e12ca70b10ad1c3f9b65a2cb4e64d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#a285e12ca70b10ad1c3f9b65a2cb4e64d">read_id</a> (std::vector&lt; uint8_t &gt; &amp;<a class="el" href="structfdc__bitstream_1_1id__field.html">id_field</a>, bool &amp;crc_error)</td></tr>
<tr class="memdesc:a285e12ca70b10ad1c3f9b65a2cb4e64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an sector ID. Start reading from the current position and read the 1st found sector ID.  <a href="classfdc__bitstream.html#a285e12ca70b10ad1c3f9b65a2cb4e64d">More...</a><br /></td></tr>
<tr class="separator:a285e12ca70b10ad1c3f9b65a2cb4e64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afb22e2181670e2b83134a690c4ea3d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structfdc__bitstream_1_1id__field.html">id_field</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#a0afb22e2181670e2b83134a690c4ea3d">read_all_idam</a> (void)</td></tr>
<tr class="memdesc:a0afb22e2181670e2b83134a690c4ea3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all IDAM in the track buffer.  <a href="classfdc__bitstream.html#a0afb22e2181670e2b83134a690c4ea3d">More...</a><br /></td></tr>
<tr class="separator:a0afb22e2181670e2b83134a690c4ea3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bb01639507122176863e47edf08dc8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#a42bb01639507122176863e47edf08dc8">read_sector_body</a> (size_t sect_length_code, std::vector&lt; uint8_t &gt; &amp;sect_data, bool &amp;crc_error, bool &amp;dam_type, bool &amp;record_not_found, bool timeout=true)</td></tr>
<tr class="memdesc:a42bb01639507122176863e47edf08dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a sector. Read sector data from the next nearest DAM/DDAM mark from the current position. This function doesn't care about the sector ID and simply reads the subsequent sector data. Combine the <a class="el" href="classfdc__bitstream.html#a285e12ca70b10ad1c3f9b65a2cb4e64d" title="Read an sector ID. Start reading from the current position and read the 1st found sector ID.">read_id()</a> function to find the desired sector ID and call this function to read the sector body data.  <a href="classfdc__bitstream.html#a42bb01639507122176863e47edf08dc8">More...</a><br /></td></tr>
<tr class="separator:a42bb01639507122176863e47edf08dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71da61708327f7e3d2796daddec1b8b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#a71da61708327f7e3d2796daddec1b8b9">write_sector_body</a> (std::vector&lt; uint8_t &gt; <a class="el" href="classfdc__bitstream.html#aa56d06aee0676001c3b245c144f12a6b">write_data</a>, bool dam_type, bool write_crc=true)</td></tr>
<tr class="memdesc:a71da61708327f7e3d2796daddec1b8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a sector. Write sector data from the current position. Please be aware that this function follows and emulates the write sequence of the FD179x/MB8876 FDC device. This means this function will skip certain bytes from the start position and then start actual data writing that includes SYNC bytes and the data address marks. To allow the user program to emulate the 'force interrupt' command of FD179x/MB8876, this function has an option not to write the CRC bytes and the last 0xff byte.  <a href="classfdc__bitstream.html#a71da61708327f7e3d2796daddec1b8b9">More...</a><br /></td></tr>
<tr class="separator:a71da61708327f7e3d2796daddec1b8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6976607e1c1803150b21cd769f8582b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfdc__bitstream_1_1sector__data.html">sector_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#a6976607e1c1803150b21cd769f8582b4">read_sector</a> (int trk, int sid, int sct)</td></tr>
<tr class="memdesc:a6976607e1c1803150b21cd769f8582b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">FD189x/MB8876 compatible TYPE-II READ SECTOR operation.  <a href="classfdc__bitstream.html#a6976607e1c1803150b21cd769f8582b4">More...</a><br /></td></tr>
<tr class="separator:a6976607e1c1803150b21cd769f8582b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bdceff0d3161a201a24a2e73aabbb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfdc__bitstream.html#ad0bdceff0d3161a201a24a2e73aabbb6">write_sector</a> (int trk, int sid, int sct, bool dam_type, std::vector&lt; uint8_t &gt; &amp;<a class="el" href="classfdc__bitstream.html#aa56d06aee0676001c3b245c144f12a6b">write_data</a>, bool fluctuate=false)</td></tr>
<tr class="memdesc:ad0bdceff0d3161a201a24a2e73aabbb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">FD189x/MB8876 compatible TYPE-II WRITE SECTOR operation.  <a href="classfdc__bitstream.html#ad0bdceff0d3161a201a24a2e73aabbb6">More...</a><br /></td></tr>
<tr class="separator:ad0bdceff0d3161a201a24a2e73aabbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8h_source.html#l00015">15</a> of file <a class="el" href="fdc__bitstream_8h_source.html">fdc_bitstream.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afbc1c3cb3ab7c90b3cdedaf255a0640e" name="afbc1c3cb3ab7c90b3cdedaf255a0640e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc1c3cb3ab7c90b3cdedaf255a0640e">&#9670;&nbsp;</a></span>fdc_bitstream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fdc_bitstream::fdc_bitstream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new fdc bitstream::fdc bitstream object. </p>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8cpp_source.html#l00024">24</a> of file <a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5d5b4821c9b9cac9d7ee88e77fb5d098" name="a5d5b4821c9b9cac9d7ee88e77fb5d098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5b4821c9b9cac9d7ee88e77fb5d098">&#9670;&nbsp;</a></span>clear_wraparound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fdc_bitstream::clear_wraparound </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8h_source.html#l00072">72</a> of file <a class="el" href="fdc__bitstream_8h_source.html">fdc_bitstream.h</a>.</p>

</div>
</div>
<a id="a0b39dd619d4fdc04b89392a1a87c7589" name="a0b39dd619d4fdc04b89392a1a87c7589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b39dd619d4fdc04b89392a1a87c7589">&#9670;&nbsp;</a></span>disable_fluctuator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fdc_bitstream::disable_fluctuator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Disable FDC read operation fluctuator </p>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8h_source.html#l00081">81</a> of file <a class="el" href="fdc__bitstream_8h_source.html">fdc_bitstream.h</a>.</p>

</div>
</div>
<a id="ab37c5cb738437d0a0fad5feeaf49ae90" name="ab37c5cb738437d0a0fad5feeaf49ae90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37c5cb738437d0a0fad5feeaf49ae90">&#9670;&nbsp;</a></span>enable_fluctuator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fdc_bitstream::enable_fluctuator </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>denominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enable FDC read operation fluctuatior If you set the fluctuator with enable_fluctuator(1,4), the VFO in the data separator will operate at rate of 3/4 and stop operation at the rate of 1/4. The operation will be determined by a random generator, so the VFO operation will be stochastic, and this introduces some uncertainty in the read data. </p>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8h_source.html#l00079">79</a> of file <a class="el" href="fdc__bitstream_8h_source.html">fdc_bitstream.h</a>.</p>

</div>
</div>
<a id="afc397441b7777ca7271458d736199e09" name="afc397441b7777ca7271458d736199e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc397441b7777ca7271458d736199e09">&#9670;&nbsp;</a></span>get_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fdc_bitstream::get_pos </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current position in the track buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t Current bit position in the track buffer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8cpp_source.html#l00400">400</a> of file <a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a>.</p>

</div>
</div>
<a id="a9a9ccb2de40c6ae4c94bb963b4817515" name="a9a9ccb2de40c6ae4c94bb963b4817515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9ccb2de40c6ae4c94bb963b4817515">&#9670;&nbsp;</a></span>get_track_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbit__array.html">bit_array</a> fdc_bitstream::get_track_data </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the track data in <a class="el" href="classbit__array.html">bit_array</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classbit__array.html">bit_array</a> Track dta in <a class="el" href="classbit__array.html">bit_array</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8cpp_source.html#l00420">420</a> of file <a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a>.</p>

</div>
</div>
<a id="a948703f45052ce4a5a1f73f4c126df43" name="a948703f45052ce4a5a1f73f4c126df43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948703f45052ce4a5a1f73f4c126df43">&#9670;&nbsp;</a></span>get_track_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t fdc_bitstream::get_track_length </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >unit = bit </p>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8h_source.html#l00066">66</a> of file <a class="el" href="fdc__bitstream_8h_source.html">fdc_bitstream.h</a>.</p>

</div>
</div>
<a id="a91d0a24862c9cdf24aa1664b48f2f917" name="a91d0a24862c9cdf24aa1664b48f2f917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d0a24862c9cdf24aa1664b48f2f917">&#9670;&nbsp;</a></span>is_wraparound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fdc_bitstream::is_wraparound </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8h_source.html#l00071">71</a> of file <a class="el" href="fdc__bitstream_8h_source.html">fdc_bitstream.h</a>.</p>

</div>
</div>
<a id="a0afb22e2181670e2b83134a690c4ea3d" name="a0afb22e2181670e2b83134a690c4ea3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afb22e2181670e2b83134a690c4ea3d">&#9670;&nbsp;</a></span>read_all_idam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structfdc__bitstream_1_1id__field.html">fdc_bitstream::id_field</a> &gt; fdc_bitstream::read_all_idam </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads all IDAM in the track buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;fdc_bitstream::id_field&gt; Read ID field data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8cpp_source.html#l00200">200</a> of file <a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a>.</p>

</div>
</div>
<a id="a19159752b4c24f253f7f44709e1bfd61" name="a19159752b4c24f253f7f44709e1bfd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19159752b4c24f253f7f44709e1bfd61">&#9670;&nbsp;</a></span>read_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fdc_bitstream::read_data </td>
          <td>(</td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>missing_clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_missing_clock</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_sync_field</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a byte from the current position in the track buffer and advance the position for one byte. When reading an ID field and a block of sector data body, ignore_missing_clock and ignore_sync_field must be set to 'true'. Otherwise, unexpected patten match to the missing-clock-pattern or sync-field-pattern may happen. If this situation occurs, the data separator will perform forcible phase correction and this causes read data error. Adversely, you must set ignore_missing_clock and ignore_sync_field to 'false' when you are searching for address markers (such as IDAM, A1* A1* A1* FE). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Read data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">missing_clock</td><td>Missing clock status (true=the read data had missing clock). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_missing_clock</td><td>Flag to ignore missing clock on reading a data (true=ignore missing clock pattern). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_sync_field</td><td>Flag to ignore SYNC field on reading a data (true=ignore SYNC field pattern). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8cpp_source.html#l00451">451</a> of file <a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a>.</p>

</div>
</div>
<a id="a285e12ca70b10ad1c3f9b65a2cb4e64d" name="a285e12ca70b10ad1c3f9b65a2cb4e64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285e12ca70b10ad1c3f9b65a2cb4e64d">&#9670;&nbsp;</a></span>read_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fdc_bitstream::read_id </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>id_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>crc_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an sector ID. Start reading from the current position and read the 1st found sector ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="structfdc__bitstream_1_1id__field.html">id_field</a></td><td>read sector ID data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">crc_error</td><td>crc error status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t Track position of the <a class="el" href="classfdc__bitstream.html#a285e12ca70b10ad1c3f9b65a2cb4e64d" title="Read an sector ID. Start reading from the current position and read the 1st found sector ID.">read_id()</a> started reading. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8cpp_source.html#l00133">133</a> of file <a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a>.</p>

</div>
</div>
<a id="a6976607e1c1803150b21cd769f8582b4" name="a6976607e1c1803150b21cd769f8582b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6976607e1c1803150b21cd769f8582b4">&#9670;&nbsp;</a></span>read_sector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfdc__bitstream_1_1sector__data.html">fdc_bitstream::sector_data</a> fdc_bitstream::read_sector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FD189x/MB8876 compatible TYPE-II READ SECTOR operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trk</td><td>Track number. </td></tr>
    <tr><td class="paramname">sid</td><td>Side number. </td></tr>
    <tr><td class="paramname">sct</td><td>Sector number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structfdc__bitstream_1_1sector__data.html">fdc_bitstream::sector_data</a> Read sector data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8cpp_source.html#l00464">464</a> of file <a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a>.</p>

</div>
</div>
<a id="a42bb01639507122176863e47edf08dc8" name="a42bb01639507122176863e47edf08dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bb01639507122176863e47edf08dc8">&#9670;&nbsp;</a></span>read_sector_body()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fdc_bitstream::read_sector_body </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sect_length_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>sect_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>crc_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>dam_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>record_not_found</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a sector. Read sector data from the next nearest DAM/DDAM mark from the current position. This function doesn't care about the sector ID and simply reads the subsequent sector data. Combine the <a class="el" href="classfdc__bitstream.html#a285e12ca70b10ad1c3f9b65a2cb4e64d" title="Read an sector ID. Start reading from the current position and read the 1st found sector ID.">read_id()</a> function to find the desired sector ID and call this function to read the sector body data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sect_length</td><td>Sector length code (0-3) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sect_data</td><td>Read sector data buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">crc_error</td><td>CRC error flag (true=error) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dam_type</td><td>(true=DDAM/false=DAM) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">record_not_found</td><td>(true=Record-not-found, false=no error) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>out enable flag (true=time out when DAM can't find in 43 bytes of data read / false = no time out) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t Track position of the <a class="el" href="classfdc__bitstream.html#a6976607e1c1803150b21cd769f8582b4" title="FD189x/MB8876 compatible TYPE-II READ SECTOR operation.">read_sector()</a> started reading. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8cpp_source.html#l00243">243</a> of file <a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a>.</p>

</div>
</div>
<a id="abea60a7ed3b79255840fac28a5a20c02" name="abea60a7ed3b79255840fac28a5a20c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea60a7ed3b79255840fac28a5a20c02">&#9670;&nbsp;</a></span>read_track()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint8_t &gt; fdc_bitstream::read_track </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read track. Reads track data from the current position until the pointer reaches to the end of the track (no wrap around). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;uint8_t&gt; Read track data (Decoded MFM data) </dd></dl>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8cpp_source.html#l00061">61</a> of file <a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a>.</p>

</div>
</div>
<a id="a5e607ac3f28e6e9b15a60c69f4b11376" name="a5e607ac3f28e6e9b15a60c69f4b11376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e607ac3f28e6e9b15a60c69f4b11376">&#9670;&nbsp;</a></span>set_fdc_params()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fdc_bitstream::set_fdc_params </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sampling_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_bit_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bit_window_ratio</em> = <code>0.75f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set FDC parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sampling_rate</td><td>The sampling rate of the floppy image (track data) in MHz unit. (e.g. 4e6 == 4MHz) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_bit_rate</td><td>The FDC bit rate in bit/sec uint. (MFM/2D == 500e3 == 500HKz) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8cpp_source.html#l00041">41</a> of file <a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a>.</p>

</div>
</div>
<a id="a028dd1120ce703253589a87186ec5ec3" name="a028dd1120ce703253589a87186ec5ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028dd1120ce703253589a87186ec5ec3">&#9670;&nbsp;</a></span>set_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fdc_bitstream::set_pos </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bit_pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set current bit position in the track buffer. The position is the bit position in the track buffer. When the sampling rate of the track buffer is 4MHz, one bit means 250ns (1/4MHz). When you set the position to 10 and the sampling rate is 4MHz, the new position will be 2.5us from the top of the track buffer. (1/4MHz * 10 = 2.5us) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_pos</td><td>New position </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8cpp_source.html#l00389">389</a> of file <a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a>.</p>

</div>
</div>
<a id="a9cdff4c84a7787e014101f0f7c1d0283" name="a9cdff4c84a7787e014101f0f7c1d0283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdff4c84a7787e014101f0f7c1d0283">&#9670;&nbsp;</a></span>set_track_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fdc_bitstream::set_track_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbit__array.html">bit_array</a>&#160;</td>
          <td class="paramname"><em>track_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new track data. Set a new track data in new a <a class="el" href="classbit__array.html">bit_array</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">track_data</td><td>New track data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8cpp_source.html#l00411">411</a> of file <a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a>.</p>

</div>
</div>
<a id="a8a75a1f7be3131cf88ba60d3fe49cd71" name="a8a75a1f7be3131cf88ba60d3fe49cd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a75a1f7be3131cf88ba60d3fe49cd71">&#9670;&nbsp;</a></span>set_vfo_gain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fdc_bitstream::set_vfo_gain </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Set VFO gain Recommended setting : High gain (high speed) mode(10.0f). Low gain (1.0f) for data reading. FDC needs to synchronized with the data stream quickly in the SYNC field before start reading the actual data (sector ID or sector body). High speed (high gain) setting will be used during the SYNC field to lock-in the read timing quickly. Low speed (low gain) setting will be used during reading data (other than SYNC field) to cancel slow spindle speed fluctuation but not follow the quick timing change such as irregular pulses in the bit stream and keep the same reading pace. </p>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8h_source.html#l00090">90</a> of file <a class="el" href="fdc__bitstream_8h_source.html">fdc_bitstream.h</a>.</p>

</div>
</div>
<a id="aa56d06aee0676001c3b245c144f12a6b" name="aa56d06aee0676001c3b245c144f12a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56d06aee0676001c3b245c144f12a6b">&#9670;&nbsp;</a></span>write_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fdc_bitstream::write_data </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>write_gate</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a byte data to the track buffer at the current position and advance the position for one byte. This function writes a byte data to the track buffer. The data wil be written at the current position, and the pointer will advance for one byte. This function also supports FD179x/MB8877 special codes. When the 'mode' is set to 'true', the special codes are recognized and handled respectively. When the 'write_gate' is set to 'false', this function will not perform actual data writing but advance the pointer. You can use this feature for dummy data writing (or just skip certain bytes). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A byte data to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Special code handling mode (true=special, false=normal) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_gate</td><td>Flag to decide whether the actual write is performed or not. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8cpp_source.html#l00434">434</a> of file <a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a>.</p>

</div>
</div>
<a id="ad0bdceff0d3161a201a24a2e73aabbb6" name="ad0bdceff0d3161a201a24a2e73aabbb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0bdceff0d3161a201a24a2e73aabbb6">&#9670;&nbsp;</a></span>write_sector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fdc_bitstream::write_sector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dam_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>write_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fluctuate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FD189x/MB8876 compatible TYPE-II WRITE SECTOR operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trk</td><td>Track number. </td></tr>
    <tr><td class="paramname">sid</td><td>Side number. </td></tr>
    <tr><td class="paramname">sct</td><td>Sector number. </td></tr>
    <tr><td class="paramname">dam_type</td><td>Data address mark type (false=DAM, true=DDAM) </td></tr>
    <tr><td class="paramname">write_data</td><td>Sector data. </td></tr>
    <tr><td class="paramname">fluctuate</td><td>Flag to control write start timing (false=deterministic timing, true=write start timing will fluctuate) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true No error </dd>
<dd>
false Record-not-found error </dd></dl>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8cpp_source.html#l00521">521</a> of file <a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a>.</p>

</div>
</div>
<a id="a71da61708327f7e3d2796daddec1b8b9" name="a71da61708327f7e3d2796daddec1b8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71da61708327f7e3d2796daddec1b8b9">&#9670;&nbsp;</a></span>write_sector_body()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fdc_bitstream::write_sector_body </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt;&#160;</td>
          <td class="paramname"><em>write_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dam_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>write_crc</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a sector. Write sector data from the current position. Please be aware that this function follows and emulates the write sequence of the FD179x/MB8876 FDC device. This means this function will skip certain bytes from the start position and then start actual data writing that includes SYNC bytes and the data address marks. To allow the user program to emulate the 'force interrupt' command of FD179x/MB8876, this function has an option not to write the CRC bytes and the last 0xff byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">write_data</td><td>The sector data to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dam_type</td><td>Specify the type of data address mark (true:DDAM, false:DAM(normal)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_crc</td><td>The flag to specify whether write the last CRC + $FF, or not. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8cpp_source.html#l00338">338</a> of file <a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a>.</p>

</div>
</div>
<a id="aebcc3997b1a78dfe74a32dd0c5ae6bf8" name="aebcc3997b1a78dfe74a32dd0c5ae6bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcc3997b1a78dfe74a32dd0c5ae6bf8">&#9670;&nbsp;</a></span>write_track()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fdc_bitstream::write_track </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>track_buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write track. Start writing from the current position until all data is written. The track buffer is treated as a ring buffer, so the pointer will wrap around if the write data goes over the buffer's end. Write track recognizes MB8876/FDC179x compatible special codes such as $f5, $f6, $f7, $fb, $fe, and so on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">track_buf</td><td>Write track data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p class="definition">Definition at line <a class="el" href="fdc__bitstream_8cpp_source.html#l00086">86</a> of file <a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="fdc__bitstream_8h_source.html">fdc_bitstream.h</a></li>
<li>fdc_bitstream/<a class="el" href="fdc__bitstream_8cpp_source.html">fdc_bitstream.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classfdc__bitstream.html">fdc_bitstream</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
